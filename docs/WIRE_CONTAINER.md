# Wire și Container - Arhitectura Dependency Injection

## Overview

Acest proiect folosește **Google Wire** pentru dependency injection și un **Container pattern** pentru gestionarea lifecycle-ului serviciilor. Această documentație explică pas cu pas cum funcționează întregul sistem.

## 1. Ce este Wire?

Wire este un tool de code generation pentru dependency injection în Go. Spre deosebire de alte framework-uri DI, Wire generează cod la compile time, nu la runtime, ceea ce înseamnă:
- Performance mai bun (fără reflection)
- Type safety complet
- Debugging mai ușor

## 2. Structura Proiectului

```
internal/
├── wire/
│   ├── wire.go          # Configurația Wire
│   ├── providers.go     # Provider functions
│   └── wire_gen.go      # Cod generat automat de Wire
├── container/
│   └── container.go     # Container struct și management
└── [alte servicii]/
```

## 3. Cum Funcționează - Pas cu Pas

### Pasul 1: Provider Functions (`internal/wire/providers.go`)

Provider functions sunt funcții care creează și configurează serviciile:

```go
func ProvideConfig() *config.Config {
    return config.NewConfig()
}

func ProvideLogger(cfg *config.Config) *logger.Logger {
    return logger.NewLogger(cfg.App.LogLevel())
}

func ProvideDatabase(cfg *config.Config, logger *logger.Logger) database.DatabaseInterface {
    return database.NewDatabase(cfg.Database, logger)
}
```

**Ce se întâmplă aici:**
- Fiecare provider function creează o instanță a unui serviciu
- Wire analizează parametrii pentru a înțelege dependințele
- `ProvideLogger` depinde de `ProvideConfig`
- `ProvideDatabase` depinde de `ProvideConfig` și `ProvideLogger`

### Pasul 2: Wire Configuration (`internal/wire/wire.go`)

```go
//go:build wireinject

func InitializeContainer() (*container.Container, error) {
    wire.Build(ProviderSet)
    return nil, nil
}
```

**Ce se întâmplă aici:**
- `//go:build wireinject` - build tag care spune că acest fișier este doar pentru Wire
- `wire.Build(ProviderSet)` - spune lui Wire să genereze cod folosind provider-urile
- Return-ul `nil, nil` este placeholder - Wire va genera implementarea reală

### Pasul 3: Provider Set (`internal/wire/providers.go`)

```go
var ProviderSet = wire.NewSet(
    ProvideConfig,
    ProvideLogger,
    ProvideDatabase,
    ProvideMigration,
    ProvideMetrics,
    ProvideServer,
    ProvideSystemCollector,
    container.NewContainer,
)
```

**Ce se întâmplă aici:**
- Wire colectează toate provider functions într-un set
- `container.NewContainer` este provider-ul final care primește toate serviciile
- Wire va analiza dependințele și va genera ordinea corectă de inițializare

### Pasul 4: Wire Code Generation (`internal/wire/wire_gen.go`)

Când rulezi `go generate` sau `wire`, Wire generează automat:

```go
// Code generated by Wire. DO NOT EDIT.

func InitializeContainer() (*container.Container, error) {
    config := ProvideConfig()
    logger := ProvideLogger(config)
    databaseInterface := ProvideDatabase(config, logger)
    migrationInterface := ProvideMigration(config, logger)
    metricsInterface := ProvideMetrics()
    serverInterface := ProvideServer(config, logger, metricsInterface)
    systemCollector := ProvideSystemCollector(metricsInterface, databaseInterface, logger)
    containerContainer := container.NewContainer(config, databaseInterface, migrationInterface, serverInterface, metricsInterface, systemCollector, logger)
    return containerContainer, nil
}
```

**Ce face Wire aici:**
1. Analizează toate dependințele
2. Calculează ordinea corectă de inițializare
3. Generează cod care apelează provider-urile în ordinea corectă
4. Pasează rezultatele între provider-uri

## 4. Container Pattern (`internal/container/container.go`)

### Container Struct

```go
type Container struct {
    Config          *config.Config
    Database        database.DatabaseInterface
    Migration       migration.MigrationInterface
    Server          fiber.ServerInterface
    Metrics         metrics.MetricsInterface
    SystemCollector *metrics.SystemCollector
    Logger          *logger.Logger
    cleanup         []func() error
}
```

**Rolul Container-ului:**
- Ține toate serviciile într-un singur loc
- Gestionează lifecycle-ul (startup/shutdown)
- Oferă access centralizat la servicii

### Constructor Principal

```go
func NewContainer(
    config *config.Config,
    database database.DatabaseInterface,
    migration migration.MigrationInterface,
    server fiber.ServerInterface,
    metricsService metrics.MetricsInterface,
    systemCollector *metrics.SystemCollector,
    logger *logger.Logger,
) *Container {
    container := &Container{
        Config:          config,
        Database:        database,
        Migration:       migration,
        Server:          server,
        Metrics:         metricsService,
        SystemCollector: systemCollector,
        Logger:          logger,
        cleanup:         make([]func() error, 0),
    }
    
    // Înregistrează funcții de cleanup
    container.cleanup = append(container.cleanup, func() error {
        database.Close()
        return nil
    })
    
    container.cleanup = append(container.cleanup, func() error {
        return migration.Close()
    })
    
    // ... alte cleanup-uri
    
    return container
}
```

**Ce se întâmplă aici:**
1. Primește toate serviciile inițializate de Wire
2. Le stochează în struct
3. Înregistrează funcții de cleanup pentru fiecare serviciu
4. Cleanup-urile vor fi apelate în ordine inversă la shutdown

### Wrapper Function

```go
func NewContainer() (*container.Container, func(), error) {
    container, err := wire.InitializeContainer()
    if err != nil {
        return nil, nil, err
    }
    
    cleanup := func() {
        container.Shutdown()
    }
    
    return container, cleanup, nil
}
```

**Rolul acestei funcții:**
- Oferă o interfață simplă pentru comenzile CLI
- Întoarce container-ul și o funcție de cleanup
- Ascunde complexitatea Wire-ului

## 5. Utilizare în Comenzile CLI

### Exemplu: Migration Command

```go
func(cmd *cobra.Command, args []string) error {
    container, err := wire.InitializeContainer()
    if err != nil {
        return fmt.Errorf("failed to initialize container: %w", err)
    }
    defer func() {
        if err := container.Shutdown(); err != nil {
            container.Logger.WithError(err).Error("Error during shutdown")
        }
    }()

    return container.Migration.Up(steps)
}
```

**Flow-ul complet:**

1. **Inițializare**: `wire.InitializeContainer()` apelează codul generat
2. **Cod generat**: Creează toate serviciile în ordinea corectă
3. **Container**: Primește toate serviciile și înregistrează cleanup-uri
4. **Utilizare**: Comanda folosește `container.Migration`
5. **Cleanup**: `defer container.Shutdown()` închide toate resursele

## 6. Dependency Graph

```
Config
├── Logger (depinde de Config)
├── Database (depinde de Config, Logger)
├── Migration (depinde de Config, Logger)
├── Server (depinde de Config, Logger, Metrics)
└── SystemCollector (depinde de Metrics, Database, Logger)
```

Wire rezolvă automat acest graf de dependințe și generează codul în ordinea corectă.

## 7. Avantajele Acestei Arhitecturi

### ✅ Avantaje

1. **Type Safety**: Toate dependințele sunt verificate la compile time
2. **Performance**: Fără reflection, overhead minimal
3. **Testabilitate**: Ușor de mockat serviciile individual
4. **Maintainability**: Adăugarea unui serviciu nou este simplă
5. **Resource Management**: Cleanup automat garantat
6. **Single Responsibility**: Fiecare provider face o singură treabă

### ⚠️ Dezavantaje

1. **Learning Curve**: Mai complex pentru începători
2. **Code Generation**: Trebuie să rulezi Wire când schimbi dependințele
3. **Build Tags**: Trebuie să înțelegi `//go:build wireinject`

## 8. Workflow de Development

### Adăugarea unui serviciu nou:

1. **Creează serviciul** în `internal/new_service/`
2. **Adaugă provider function** în `internal/wire/providers.go`:
   ```go
   func ProvideNewService(deps...) NewServiceInterface {
       return newservice.NewService(deps...)
   }
   ```
3. **Adaugă în ProviderSet**:
   ```go
   var ProviderSet = wire.NewSet(
       // ... existing providers
       ProvideNewService,
       container.NewContainer,
   )
   ```
4. **Adaugă în Container struct**:
   ```go
   type Container struct {
       // ... existing fields
       NewService NewServiceInterface
   }
   ```
5. **Rulează Wire**: `go generate ./internal/wire`
6. **Adaugă cleanup** în constructor dacă e necesar

### Regenerarea codului Wire:

```bash
# Din root directory
go generate ./internal/wire

# Sau direct
cd internal/wire && wire
```

## 9. Debugging și Troubleshooting

### Erori comune:

1. **Circular dependencies**: Wire va detecta și va da eroare
2. **Missing providers**: Wire va da eroare dacă lipsește un provider
3. **Interface mismatches**: Compile time errors

### Pentru debugging:

1. Verifică `wire_gen.go` pentru a vedea ordinea de inițializare
2. Folosește logger-ul pentru a trace inițializarea serviciilor
3. Testează provider-urile individual

## 10. Best Practices

1. **Keep providers simple**: O singură responsabilitate per provider
2. **Use interfaces**: Provider-urile să întoarcă interfețe, nu struct-uri concrete
3. **Proper cleanup**: Adaugă cleanup pentru toate resursele
4. **Test with mocks**: Mockează interfețele pentru unit testing
5. **Regenerate regularly**: Rulează Wire după fiecare schimbare de dependințe

## 11. Exemplu Complet de Flow

```
1. CLI command starts
   ↓
2. Calls wire.InitializeContainer()
   ↓
3. Wire executes generated code:
   - config := ProvideConfig()
   - logger := ProvideLogger(config)
   - database := ProvideDatabase(config, logger)
   - migration := ProvideMigration(config, logger)
   - metrics := ProvideMetrics()
   - server := ProvideServer(config, logger, metrics)
   - systemCollector := ProvideSystemCollector(metrics, database, logger)
   - container := NewContainer(config, database, migration, server, metrics, systemCollector, logger)
   ↓
4. Container is returned with all services initialized
   ↓
5. Command uses container.Migration.Up()
   ↓
6. defer container.Shutdown() cleans up all resources
```

Această arhitectură asigură că toate serviciile sunt inițializate corect, dependințele sunt rezolvate automat, și resursele sunt curățate la final.